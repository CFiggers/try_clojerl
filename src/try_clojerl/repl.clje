(ns try-clojerl.repl)

(declare build-reply eval-string)

(defn init
  [req state]
  ;; :compress should be true once ERL-494 is solved
  (let [opts #erl{:compress     false
                  :idle_timeout 600000}]
    #erl[:cowboy_websocket req state opts]))

(defn websocket_init [state]
  (lager/log.e :info (erlang/self.e) "REPL process started")
  (ns clje.user
    (:require [clojure.repl :refer (source apropos dir pst doc find-doc)]
              [clojure.pprint :refer (pp pprint)]))
  (let [erlang-version  (-> :system_version
                            erlang/system_info.e
                            erlang/list_to_binary.e)
        clojerl-version (str "Clojerl " (clojure-version))
        message         (str erlang-version clojerl-version)
        reply           (build-reply :message message)]
    #erl[:reply reply state]))

(defn* websocket_handle [#erl[:text data] state]
  (let* [json          (jsx/decode.e data #erl(:return_maps))
         #erl[res out err] (eval-string (get json "cmd"))
         out-frame     (build-reply :result res
                                    :stdout out
                                    :stderr err)]
    #erl[:reply out-frame state]))

(defn websocket_info [_info state]
  #erl[:ok state])

(defn terminate [reason _ state]
  (lager/log.e :info
               (erlang/self.e)
               "REPL process terminated: ~p" #erl(reason))
  :ok)

(defn eval-string [s]
  (with-open [out (erlang.io.StringWriter.)
              err (erlang.io.StringWriter.)]
    (binding [*out* out *err* err]
      (let [res (try (-> s read-string eval pr-str)
                  (catch _ e
                    (.write *err* (str "Error: " (pr-str e)))
                    ""))]
        #erl[res (str *out*) (str *err*)]))))

(defn prompt [] (str *ns* "=> "))

(defn build-reply
  [& keyvals]
  #erl[:text
       (jsx/encode.e (merge #erl{:prompt (prompt)}
                            (apply hash-map keyvals)))])
